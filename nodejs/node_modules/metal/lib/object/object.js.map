{"version":3,"sources":["../../src/object/object.js"],"names":["object","target","key","source","args","i","length","name","scope","window","parts","split","reduce","part","obj","fn","mappedObj","keys","Object","obj1","obj2","keys1","keys2"],"mappings":"AAAA;;AAEA;;;;;;;;;;;;IAGMA,M;;;;;;;;AACL;;;;;;wBAMaC,M,EAAiB;AAC7B,OAAIC,YAAJ;AACA,OAAIC,eAAJ;;AAF6B,qCAANC,IAAM;AAANA,QAAM;AAAA;;AAG7B,QAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,KAAKE,MAAzB,EAAiCD,GAAjC,EAAsC;AACrCF,aAASC,KAAKC,CAAL,CAAT;AACA;AACA;AACA;AACA,SAAKH,GAAL,IAAYC,MAAZ,EAAoB;AACnBF,YAAOC,GAAP,IAAcC,OAAOD,GAAP,CAAd;AACA;AACD;AACD,UAAOD,MAAP;AACA;;AAED;;;;;;;;;;kCAOuBM,I,EAAsB;AAAA,OAAhBC,KAAgB,uEAARC,MAAQ;;AAC5C,OAAMC,QAAQH,KAAKI,KAAL,CAAW,GAAX,CAAd;AACA,UAAOD,MAAME,MAAN,CAAa,UAACC,IAAD,EAAOX,GAAP;AAAA,WAAeW,KAAKX,GAAL,CAAf;AAAA,IAAb,EAAuCM,KAAvC,CAAP;AACA;;AAED;;;;;;;;;;sBAOWM,G,EAAKC,E,EAAI;AACnB,OAAMC,YAAY,EAAlB;AACA,OAAMC,OAAOC,OAAOD,IAAP,CAAYH,GAAZ,CAAb;AACA,QAAK,IAAIT,IAAI,CAAb,EAAgBA,IAAIY,KAAKX,MAAzB,EAAiCD,GAAjC,EAAsC;AACrCW,cAAUC,KAAKZ,CAAL,CAAV,IAAqBU,GAAGE,KAAKZ,CAAL,CAAH,EAAYS,IAAIG,KAAKZ,CAAL,CAAJ,CAAZ,CAArB;AACA;AACD,UAAOW,SAAP;AACA;;AAED;;;;;;;;;;+BAOoBG,I,EAAMC,I,EAAM;AAC/B,OAAID,SAASC,IAAb,EAAmB;AAClB,WAAO,IAAP;AACA;;AAED,OAAMC,QAAQH,OAAOD,IAAP,CAAYE,IAAZ,CAAd;AACA,OAAMG,QAAQJ,OAAOD,IAAP,CAAYG,IAAZ,CAAd;AACA,OAAIC,MAAMf,MAAN,KAAiBgB,MAAMhB,MAA3B,EAAmC;AAClC,WAAO,KAAP;AACA;;AAED,QAAK,IAAID,IAAI,CAAb,EAAgBA,IAAIgB,MAAMf,MAA1B,EAAkCD,GAAlC,EAAuC;AACtC,QAAIc,KAAKE,MAAMhB,CAAN,CAAL,MAAmBe,KAAKC,MAAMhB,CAAN,CAAL,CAAvB,EAAuC;AACtC,YAAO,KAAP;AACA;AACD;AACD,UAAO,IAAP;AACA;;;;;;kBAGaL,M","file":"object.js","sourcesContent":["'use strict';\n\n/**\n * Set of utilities for object operations\n */\nclass object {\n\t/**\n\t * Copies all the members of a source object to a target object.\n\t * @param {Object} target Target object.\n\t * @param {...Object} var_args The objects from which values will be copied.\n\t * @return {Object} Returns the target object reference.\n\t */\n\tstatic mixin(target, ...args) {\n\t\tlet key;\n\t\tlet source;\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tsource = args[i];\n\t\t\t// Possible prototype chain leak, breaks 1 metal-dom and\n\t\t\t// 1 metal-incremental-dom test if guard-for-in rule is addressed\n\t\t\t// eslint-disable-next-line\n\t\t\tfor (key in source) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Returns an object based on its fully qualified external name.\n\t * @param {string} name The fully qualified name.\n\t * @param {object=} scope The object within which to look; default is\n\t *     <code>window</code>.\n\t * @return {?} The value (object or primitive) or, if not found, undefined.\n\t */\n\tstatic getObjectByName(name, scope = window) {\n\t\tconst parts = name.split('.');\n\t\treturn parts.reduce((part, key) => part[key], scope);\n\t}\n\n\t/**\n\t * Returns a new object with the same keys as the given one, but with\n\t * their values set to the return values of the specified function.\n\t * @param {!Object} obj\n\t * @param {!function(string, *)} fn\n\t * @return {!Object}\n\t */\n\tstatic map(obj, fn) {\n\t\tconst mappedObj = {};\n\t\tconst keys = Object.keys(obj);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tmappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);\n\t\t}\n\t\treturn mappedObj;\n\t}\n\n\t/**\n\t * Checks if the two given objects are equal. This is done via a shallow\n\t * check, including only the keys directly contained by the 2 objects.\n\t * @param {Object} obj1\n\t * @param {Object} obj2\n\t * @return {boolean}\n\t */\n\tstatic shallowEqual(obj1, obj2) {\n\t\tif (obj1 === obj2) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst keys1 = Object.keys(obj1);\n\t\tconst keys2 = Object.keys(obj2);\n\t\tif (keys1.length !== keys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < keys1.length; i++) {\n\t\t\tif (obj1[keys1[i]] !== obj2[keys1[i]]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport default object;\n"]}