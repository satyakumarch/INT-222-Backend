{"version":3,"sources":["../src/EventEmitter.js"],"names":["singleArray_","EventEmitter","events_","listenerHandlers_","shouldUseFacade_","holder","handler","Array","isArray","push","event","listener","defaultListener","validateListener_","events","toEventsArray_","i","length","addSingleListener_","origin","runListenerHandlers_","default","fn","addHandler_","getShouldUseFacade","facade","preventDefault","preventedDefault","target","type","listeners","getRawListeners_","args","slice","arguments","runListeners_","buildFacade_","directListeners","toArray","concat","map","amount","many_","self","handlerInternal","removeListener","apply","listenerObj","removeMatchingListenerObjs_","addListener","many","listenerObjs","finalListeners","matchesListener_","off","handlers","defaultListeners","j","shouldUseFacade","TypeError","val"],"mappings":"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","file":"EventEmitter.js","sourcesContent":["'use strict';\n\nimport {array, Disposable, isFunction, isString} from 'metal';\nimport EventHandle from './EventHandle';\n\nconst singleArray_ = [0];\n\n/**\n * EventEmitter utility.\n * @extends {Disposable}\n */\nclass EventEmitter extends Disposable {\n\t/**\n\t * EventEmitter constructor\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Holds event listeners scoped by event type.\n\t\t * @type {Object<string, !Array<!function()>>}\n\t\t * @protected\n\t\t */\n\t\tthis.events_ = null;\n\n\t\t/**\n\t\t * Handlers that are triggered when an event is listened to.\n\t\t * @type {Array}\n\t\t */\n\t\tthis.listenerHandlers_ = null;\n\n\t\t/**\n\t\t * Configuration option which determines if an event facade should be sent\n\t\t * as a param of listeners when emitting events. If set to true, the facade\n\t\t * will be passed as the first argument of the listener.\n\t\t * @type {boolean}\n\t\t * @protected\n\t\t */\n\t\tthis.shouldUseFacade_ = false;\n\t}\n\n\t/**\n\t * Adds a handler to given holder variable. If the holder doesn't have a\n\t * value yet, it will receive the handler directly. If the holder is an array,\n\t * the value will just be added to it. Otherwise, the holder will be set to a\n\t * new array containing its previous value plus the new handler.\n\t * @param {*} holder\n\t * @param {!function()|Object} handler\n\t * @return {*} The holder's new value.\n\t * @protected\n\t */\n\taddHandler_(holder, handler) {\n\t\tif (!holder) {\n\t\t\tholder = handler;\n\t\t} else {\n\t\t\tif (!Array.isArray(holder)) {\n\t\t\t\tholder = [holder];\n\t\t\t}\n\t\t\tholder.push(handler);\n\t\t}\n\t\treturn holder;\n\t}\n\n\t/**\n\t * Adds a listener to the end of the listeners array for the specified events.\n\t * @param {!(Array|string)} event\n\t * @param {!Function} listener\n\t * @param {boolean} defaultListener Flag indicating if this listener is a default\n\t *   action for this event. Default actions are run last, and only if no previous\n\t *   listener call `preventDefault()` on the received event facade.\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\taddListener(event, listener, defaultListener) {\n\t\tthis.validateListener_(listener);\n\n\t\tconst events = this.toEventsArray_(event);\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tthis.addSingleListener_(events[i], listener, defaultListener);\n\t\t}\n\n\t\treturn new EventHandle(this, event, listener);\n\t}\n\n\t/**\n\t * Adds a listener to the end of the listeners array for a single event.\n\t * @param {string} event\n\t * @param {!Function} listener\n\t * @param {boolean} defaultListener Flag indicating if this listener is a default\n\t *   action for this event. Default actions are run last, and only if no previous\n\t *   listener call `preventDefault()` on the received event facade.\n\t * @param {Function=} origin The original function that was added as a\n\t *   listener, if there is any.\n\t * @protected\n\t */\n\taddSingleListener_(event, listener, defaultListener, origin) {\n\t\tthis.runListenerHandlers_(event);\n\t\tif (defaultListener || origin) {\n\t\t\tlistener = {\n\t\t\t\tdefault: defaultListener,\n\t\t\t\tfn: listener,\n\t\t\t\torigin: origin,\n\t\t\t};\n\t\t}\n\t\tthis.events_ = this.events_ || {};\n\t\tthis.events_[event] = this.addHandler_(this.events_[event], listener);\n\t}\n\n\t/**\n\t * Builds facade for the given event.\n\t * @param {string} event\n\t * @return {Object}\n\t * @protected\n\t */\n\tbuildFacade_(event) {\n\t\tif (this.getShouldUseFacade()) {\n\t\t\tconst facade = {\n\t\t\t\tpreventDefault: function() {\n\t\t\t\t\tfacade.preventedDefault = true;\n\t\t\t\t},\n\t\t\t\ttarget: this,\n\t\t\t\ttype: event,\n\t\t\t};\n\t\t\treturn facade;\n\t\t}\n\t}\n\n\t/**\n\t * Disposes of this instance's object references.\n\t * @override\n\t */\n\tdisposeInternal() {\n\t\tthis.events_ = null;\n\t}\n\n\t/**\n\t * Execute each of the listeners in order with the supplied arguments.\n\t * @param {string} event\n\t * @param {*} opt_args [arg1], [arg2], [...]\n\t * @return {boolean} Returns true if event had listeners, false otherwise.\n\t */\n\temit(event) {\n\t\tconst listeners = this.getRawListeners_(event);\n\t\tif (listeners.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst args = array.slice(arguments, 1); // eslint-disable-line\n\t\tthis.runListeners_(listeners, args, this.buildFacade_(event));\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the listener objects for the given event, if there are any.\n\t * @param {string} event\n\t * @return {!Array}\n\t * @protected\n\t */\n\tgetRawListeners_(event) {\n\t\tconst directListeners = toArray(this.events_ && this.events_[event]);\n\t\treturn directListeners.concat(\n\t\t\ttoArray(this.events_ && this.events_['*'])\n\t\t);\n\t}\n\n\t/**\n\t * Gets the configuration option which determines if an event facade should\n\t * be sent as a param of listeners when emitting events. If set to true, the\n\t * facade will be passed as the first argument of the listener.\n\t * @return {boolean}\n\t */\n\tgetShouldUseFacade() {\n\t\treturn this.shouldUseFacade_;\n\t}\n\n\t/**\n\t * Returns an array of listeners for the specified event.\n\t * @param {string} event\n\t * @return {Array} Array of listeners.\n\t */\n\tlisteners(event) {\n\t\treturn this.getRawListeners_(event).map(\n\t\t\tlistener => (listener.fn ? listener.fn : listener)\n\t\t);\n\t}\n\n\t/**\n\t * Adds a listener that will be invoked a fixed number of times for the\n\t * events. After each event is triggered the specified amount of times, the\n\t * listener is removed for it.\n\t * @param {!(Array|string)} event\n\t * @param {number} amount The amount of times this event should be listened\n\t * to.\n\t * @param {!Function} listener\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\tmany(event, amount, listener) {\n\t\tconst events = this.toEventsArray_(event);\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tthis.many_(events[i], amount, listener);\n\t\t}\n\n\t\treturn new EventHandle(this, event, listener);\n\t}\n\n\t/**\n\t * Adds a listener that will be invoked a fixed number of times for a single\n\t * event. After the event is triggered the specified amount of times, the\n\t * listener is removed.\n\t * @param {string} event\n\t * @param {number} amount The amount of times this event should be listened\n\t * to.\n\t * @param {!Function} listener\n\t * @protected\n\t */\n\tmany_(event, amount, listener) {\n\t\tconst self = this;\n\n\t\tif (amount <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tfunction handlerInternal() {\n\t\t\tif (--amount === 0) {\n\t\t\t\tself.removeListener(event, handlerInternal);\n\t\t\t}\n\t\t\tlistener.apply(self, arguments); // eslint-disable-line\n\t\t}\n\n\t\tself.addSingleListener_(event, handlerInternal, false, listener);\n\t}\n\n\t/**\n\t * Checks if a listener object matches the given listener function. To match,\n\t * it needs to either point to that listener or have it as its origin.\n\t * @param {!Object} listenerObj\n\t * @param {!Function} listener\n\t * @return {boolean}\n\t * @protected\n\t */\n\tmatchesListener_(listenerObj, listener) {\n\t\tconst fn = listenerObj.fn || listenerObj;\n\t\treturn (\n\t\t\tfn === listener ||\n\t\t\t(listenerObj.origin && listenerObj.origin === listener) // eslint-disable-line\n\t\t);\n\t}\n\n\t/**\n\t * Removes a listener for the specified events.\n\t * Caution: changes array indices in the listener array behind the listener.\n\t * @param {!(Array|string)} event\n\t * @param {!Function} listener\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\toff(event, listener) {\n\t\tthis.validateListener_(listener);\n\t\tif (!this.events_) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst events = this.toEventsArray_(event);\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tthis.events_[events[i]] = this.removeMatchingListenerObjs_(\n\t\t\t\ttoArray(this.events_[events[i]]),\n\t\t\t\tlistener\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a listener to the end of the listeners array for the specified events.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\ton() {\n\t\treturn this.addListener.apply(this, arguments); // eslint-disable-line\n\t}\n\n\t/**\n\t * Adds handler that gets triggered when an event is listened to on this\n\t * instance.\n\t * @param {!function()} handler\n\t */\n\tonListener(handler) {\n\t\tthis.listenerHandlers_ = this.addHandler_(\n\t\t\tthis.listenerHandlers_,\n\t\t\thandler\n\t\t); // eslint-disable-line\n\t}\n\n\t/**\n\t * Adds a one time listener for the events. This listener is invoked only the\n\t * next time each event is fired, after which it is removed.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\tonce(events, listener) {\n\t\treturn this.many(events, 1, listener);\n\t}\n\n\t/**\n\t * Removes all listeners, or those of the specified events. It's not a good\n\t * idea to remove listeners that were added elsewhere in the code,\n\t * especially when it's on an emitter that you didn't create.\n\t * @param {(Array|string)=} event\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tremoveAllListeners(event) {\n\t\tif (this.events_) {\n\t\t\tif (event) {\n\t\t\t\tconst events = this.toEventsArray_(event);\n\t\t\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\t\t\tthis.events_[events[i]] = null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.events_ = null;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all listener objects from the given array that match the given\n\t * listener function.\n\t * @param {Array.<Object>} listenerObjs\n\t * @param {!Function} listener\n\t * @return {Array.<Object>|Object} The new listeners array for this event.\n\t * @protected\n\t */\n\tremoveMatchingListenerObjs_(listenerObjs, listener) {\n\t\tconst finalListeners = [];\n\t\tfor (let i = 0; i < listenerObjs.length; i++) {\n\t\t\tif (!this.matchesListener_(listenerObjs[i], listener)) {\n\t\t\t\tfinalListeners.push(listenerObjs[i]);\n\t\t\t}\n\t\t}\n\t\treturn finalListeners.length > 0 ? finalListeners : null;\n\t}\n\n\t/**\n\t * Removes a listener for the specified events.\n\t * Caution: changes array indices in the listener array behind the listener.\n\t * @param {!(Array|string)} events\n\t * @param {!Function} listener\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tremoveListener() {\n\t\treturn this.off.apply(this, arguments); // eslint-disable-line\n\t}\n\n\t/**\n\t * Runs the handlers when an event is listened to.\n\t * @param {string} event\n\t * @protected\n\t */\n\trunListenerHandlers_(event) {\n\t\tlet handlers = this.listenerHandlers_;\n\t\tif (handlers) {\n\t\t\thandlers = toArray(handlers);\n\t\t\tfor (let i = 0; i < handlers.length; i++) {\n\t\t\t\thandlers[i](event);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Runs the given listeners.\n\t * @param {!Array} listeners\n\t * @param {!Array} args\n\t * @param {Object} facade\n\t * @protected\n\t */\n\trunListeners_(listeners, args, facade) {\n\t\tif (facade) {\n\t\t\targs.push(facade);\n\t\t}\n\n\t\tconst defaultListeners = [];\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst listener = listeners[i].fn || listeners[i];\n\t\t\tif (listeners[i].default) {\n\t\t\t\tdefaultListeners.push(listener);\n\t\t\t} else {\n\t\t\t\tlistener.apply(this, args);\n\t\t\t}\n\t\t}\n\t\tif (!facade || !facade.preventedDefault) {\n\t\t\tfor (let j = 0; j < defaultListeners.length; j++) {\n\t\t\t\tdefaultListeners[j].apply(this, args);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Sets the configuration option which determines if an event facade should\n\t * be sent as a param of listeners when emitting events. If set to true, the\n\t * facade will be passed as the first argument of the listener.\n\t * @param {boolean} shouldUseFacade\n\t * @return {!Object} Returns emitter, so calls can be chained.\n\t */\n\tsetShouldUseFacade(shouldUseFacade) {\n\t\tthis.shouldUseFacade_ = shouldUseFacade;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Converts the parameter to an array if only one event is given. Reuses the\n\t * same array each time this conversion is done, to avoid using more memory\n\t * than necessary.\n\t * @param  {!(Array|string)} events\n\t * @return {!Array}\n\t * @protected\n\t */\n\ttoEventsArray_(events) {\n\t\tif (isString(events)) {\n\t\t\tsingleArray_[0] = events;\n\t\t\tevents = singleArray_;\n\t\t}\n\t\treturn events;\n\t}\n\n\t/**\n\t * Checks if the given listener is valid, throwing an exception when it's not.\n\t * @param  {*} listener\n\t * @protected\n\t */\n\tvalidateListener_(listener) {\n\t\tif (!isFunction(listener)) {\n\t\t\tthrow new TypeError('Listener must be a function');\n\t\t}\n\t}\n}\n\n/**\n * Converts to an array\n * @param {Object} val\n * @return {Array}\n */\nfunction toArray(val) {\n\tval = val || [];\n\treturn Array.isArray(val) ? val : [val];\n}\n\nexport default EventEmitter;\n"]}