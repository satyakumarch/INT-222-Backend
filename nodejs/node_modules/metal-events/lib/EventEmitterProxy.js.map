{"version":3,"sources":["../src/EventEmitterProxy.js"],"names":["EventEmitterProxy","originEmitter","targetEmitter","blacklist","whitelist","blacklist_","originEmitter_","pendingEvents_","proxiedEvents_","targetEmitter_","whitelist_","startProxy_","event","listener","on","removeListeners_","emit","shouldProxyEvent_","tryToAddListener_","events","Object","keys","i","length","removeListener","forEach","proxyEvent","onListener","bind","addListener_","emitOnTarget_","push"],"mappings":"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","file":"EventEmitterProxy.js","sourcesContent":["'use strict';\n\nimport {Disposable} from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\t/**\n\t * @param {EventEmitter} originEmitter Events originated on this emitter\n\t * will be fired for the target emitter's listeners as well.\n\t * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n\t * will also be triggered when the event is fired by the origin emitter.\n\t * @param {Object} blacklist Optional blacklist of events that should not be\n\t * proxied.\n\t * @param {Object} whitelist\n\t */\n\tconstructor(originEmitter, targetEmitter, blacklist, whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = blacklist;\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * A list of events that are pending to be listened by an actual origin\n\t\t * emitter. Events are stored here when the origin doesn't exist, so they\n\t\t * can be set on a new origin when one is set.\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis.pendingEvents_ = null;\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object<string, !EventHandle>}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = null;\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the given listener for the given event.\n\t * @param {string} event\n\t * @param {!function()} listener\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListener_(event, listener) {\n\t\treturn this.originEmitter_.on(event, listener);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.removeListeners_();\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Emits the specified event type on the target emitter.\n\t * @protected\n\t */\n\temitOnTarget_(...args) {\n\t\tthis.targetEmitter_.emit(...args);\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent(event) {\n\t\tif (this.shouldProxyEvent_(event)) {\n\t\t\tthis.tryToAddListener_(event);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the proxy listener for all events.\n\t * @protected\n\t */\n\tremoveListeners_() {\n\t\tif (this.proxiedEvents_) {\n\t\t\tconst events = Object.keys(this.proxiedEvents_);\n\t\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\t\tthis.proxiedEvents_[events[i]].removeListener();\n\t\t\t}\n\t\t\tthis.proxiedEvents_ = null;\n\t\t}\n\t\tthis.pendingEvents_ = null;\n\t}\n\n\t/**\n\t * Changes the origin emitter. This automatically detaches any events that\n\t * were already being proxied from the previous emitter, and starts proxying\n\t * them on the new emitter instead.\n\t * @param {!EventEmitter} originEmitter\n\t */\n\tsetOriginEmitter(originEmitter) {\n\t\tconst events =\n\t\t\tthis.originEmitter_ && this.proxiedEvents_\n\t\t\t\t? Object.keys(this.proxiedEvents_)\n\t\t\t\t: this.pendingEvents_;\n\t\tthis.originEmitter_ = originEmitter;\n\t\tif (events) {\n\t\t\tthis.removeListeners_();\n\t\t\tevents.forEach(event => this.proxyEvent(event));\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_ && this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_ || !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.onListener(this.proxyEvent.bind(this));\n\t}\n\n\t/**\n\t * Adds a listener to the origin emitter, if it exists. Otherwise, stores\n\t * the pending listener so it can be used on a future origin emitter.\n\t * @param {string} event\n\t * @protected\n\t */\n\ttryToAddListener_(event) {\n\t\tif (this.originEmitter_) {\n\t\t\tthis.proxiedEvents_ = this.proxiedEvents_ || {};\n\t\t\tthis.proxiedEvents_[event] = this.addListener_(\n\t\t\t\tevent,\n\t\t\t\tthis.emitOnTarget_.bind(this, event)\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pendingEvents_ = this.pendingEvents_ || [];\n\t\t\tthis.pendingEvents_.push(event);\n\t\t}\n\t}\n}\n\nexport default EventEmitterProxy;\n"]}